<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: stateToPvsSpecificationWriter.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: stateToPvsSpecificationWriter.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/**
     * @fileOverview Utility functions to translate from a graphic specification to a pvs specification.
     * @version 0.1
     */


/**
     * 
     * @module stateToPvsSpecificationWriter
 */


  /************* 	Exported Function 	                   ************************************************/


   module.exports = {
	               newPVSSpecification : newPVSSpecification,
                       addState : addState,
		       addTransition : addTransition,
	               addEntryCondition : addEntryCondition,
		       setInitialState   : setInitialState,
	               addConditionInTransition : addConditionInTransition	

   };

  /**************     State Variables                              ************************************************/

  var listState = new stateStructure();
  var writer    = new writerOnContent();

  /**************  Exported Functions Definition 		    ************************************************/

/** 
 *  Create a new pvs specification   
 *
 *  @param nameTheory           - Name of the pvs theory which will be created    
 *  @param editor               - Reference to the editor where the pvs specification has to be written                    
 *
 *  @returns void 
 *	      
 */

function newPVSSpecification(nameTheory, editor )
{
	var newContent;

	writer.setNameTheory(nameTheory);

	newContent = rebuild();
	editor.setValue(newContent);
        editor.clearSelection();
        editor.moveCursorTo(0, 0); 
	
}


/** 
 *  Set the initial state for the state machine     
 *
 *  @param {string} initialState         - Initial state to be used  
 *  @param editor                        - Reference to the editor where the pvs specification has to be written                    
 *
 *  @returns void 
 *	      
 */

function setInitialState(initialState, editor)
{
        var newContent;
	
	writer.setInitialState(initialState);

	newContent = rebuild();

	editor.setValue(newContent);
        editor.clearSelection();
        editor.moveCursorTo(0, 0);       
}
 
/** 
 *  Add a state in the specification  
 *
 *  @param newState             - Object having name and id property  
 *  @param editor               - Reference to the editor where the pvs specification has to be written                    
 *
 *  @returns void 
 *	      
 */
  function addState(newState, editor)
  {
        var newContent;

        ///Adding newState in local structure 
	listState.addItem(newState.id, newState.name);
		
        writer.addState(newState.name );
	
	newContent = rebuild();

	editor.setValue(newContent);
        editor.clearSelection();
        editor.moveCursorTo(0, 0);       
        
  } 

/** 
 *  Add a transition in the PVS Specification  
 *
 *  @param newTransition             - Object having name and id property  
 *  @param editor                    - Reference to the editor where the pvs specification has to be written                    
 *
 *  @returns void 
 *	      
 */	
  function addTransition(newTransition, id, editor)
  {
        var newContent;
	
	writer.addTransition(newTransition, id);

	newContent = rebuild();
	editor.setValue(newContent);
        editor.clearSelection();
        editor.moveCursorTo(0, 0);       
        

  }

/** 
 *  Add a entry condition for a transition function   
 *
 *  @param {int }   idTransition         - Identificator of the transition has to be modifed 
 *  @param {string} condition            - Condition has to be added 
 *  @param {string} [booleanConnect]     - Boolean operator used to connects this condition to the previous ones  
 *  @param editor                        - Reference to the editor where the pvs specification has to be written                    
 *
 *  @returns void 
 *	      
 */
  function addEntryCondition(idTransition, condition, editor, booleanConnect )
  {
	var newContent;
	
	writer.addEntryCondition(idTransition, condition, booleanConnect);

	newContent = rebuild();
	editor.setValue(newContent);
	editor.clearSelection();
	editor.moveCursorTo(0, 0);
	
	
  } 

  
/** 
 *  Add a condition for a transition function   
 *
 *  @param {int }   idTransition         - Identificator of the transition has to be modified 
 *  @param source                        - source state for the condition is being added 
 *  @param target                        - target state for the condition is being added   
 *  @param editor                        - Reference to the editor where the pvs specification has to be written                    
 *
 *  @returns void 
 *	      
 */
  function addConditionInTransition(transitionId, source, target, editor)
  {
	var newContent;

	writer.addCondition(transitionId, source, target );
	newContent = rebuild();
	editor.setValue(newContent);
	editor.clearSelection();
	editor.moveCursorTo(0, 0);	
	
  }
  

  /**************  Utility Functions private to the module    ******************************************************/              

 function stateStructure()
 {
 	this.length = 0;
        this.items  = {};
	this.lastAdded ;
        
        this.addItem = function(key, value)
        {
	
		this.items[key] = value;
                this.length ++ ;	
                return this.length;	
        }	

 }

 function writerOnContent()
 { 

	this.nameTheory ;

        this.init = "";
        this.end  = ""; 

	this.stateString = "StateName: TYPE" ;
        this.stateStringComment = "%-- StateName enumerates machine state names"; 	

	this.machineState = "State: TYPE = [#\n    current_state: StateName \n  #]";
	this.machineStateComment = "%-- State is the machine state";

	this.initialState = "initial_state: State";
	this.initialStateComment = "%-- State is the machine state"; 

	this.transition = new Array();
	this.lastTransitionUsed;
	var delimitator = "";   
	
	

	this.setNameTheory = function(nametheory)
	{
		this.nameTheory = nametheory;
                this.init = this.nameTheory + ": THEORY\n BEGIN\n\n";
                this.end  = "\n END " + this.nameTheory;
	}
        
	this.setInitialState = function(initialState)
	{
		this.initialState = "initial_state: State = (#\n    " + "current_state := " + initialState + "\n  #)";
	}
	this.addState = function(newState)
	{
	        var index;
                var symbol_beg = "";
		var newStateString;

		///Checking if a state has been already added 
		index = this.stateString.indexOf('}');
		if( index == -1 ) ///If not, add also the '{' at the beginning 
		{
		    symbol_beg = " = {";
		    index = this.stateString.indexOf('E') + 1;
	        }
		
		newStateString = this.stateString.substring(0, index);
		newStateString = newStateString + symbol_beg + delimitator + newState + '}';
		delimitator = ',';
		this.stateString = newStateString;

	}
	this.addTransition = function(newTransition, idTransition)
	{
		var tmp = new Object();

		tmp.comment = "  %-- " + newTransition + " transition function\n";
		tmp.string = "  " + newTransition + "(st: (per_" + newTransition + ") ) : State =\n";
		tmp.content = " ";
		tmp.aux_func = "  per_"+newTransition+"(st:State ) : bool";
		tmp.id = idTransition;
		this.lastTransitionUsed =  this.transition.push(tmp) - 1;
	        
	}
	this.getAllTransition = function ()
	{	
		var stringToReturn = "";
		var length = this.transition.length;
		for( var i = 0; i &lt; length; i ++)	
		{
		     stringToReturn = stringToReturn + this.transition[i].comment + this.transition[i].aux_func + "\n" + this.transition[i].string  + 
                                      "    COND\n" + this.transition[i].content + "   ENDCOND\n";
	
		}
		return stringToReturn;
	
	}
	this.addCondition = function (transitionId, source, target )
	{
	        //FIXME: Find a way to avoid this linear searching 
		var i  = this.lastTransitionUsed;
		if( i == transitionId ) 
		{   
		    this.transition[i].content = this.transition[i].content + "     st'current_state = " + source.name + "\n" +
                                                 "     -> st WITH [current_state := " + target.name + "],\n";
		    return;
		}

		var length = this.transition.length;
	        for( i = 0; i  &lt; length; i++ )
	        {
		     if( this.transition[i].id == transitionId )
	                 break;
		}
		if( i == length)
                {
		    console.log("ERROR Module:stateToPvsSpecificationWriter; Transition not Found ");
	            return;
		}
		this.transition[i].content = this.transition[i].content + "     st'current_state = " + source.name + "\n" +
                                             "     -> st WITH [current_state := " + target.name + "],\n";
		

	
	}
	this.addEntryCondition = function(transitionId, condition, booleanConnect)
	{
	        var length = this.transition.length;
		var index;
		
	        for( var i = 0; i  &lt; length; i++ )
	        {
		     if( this.transition[i].id == transitionId )
	                 break;
		}
		if( i == length)
                {
		    console.log("ERROR Module:stateToPvsSpecificationWriter; Transition not Found ");
	            return;
		}

	        index = this.transition[i].aux_func.indexOf('=');
		if( index == -1 )
		    this.transition[i].aux_func = this.transition[i].aux_func + " =\n";
	
		if( ! booleanConnect)
		    booleanConnect = "";
		
		this.transition[i].aux_func = this.transition[i].aux_func + " " +  booleanConnect +  "    st'" + condition;
		
			
	
	}
	this.getStateString = function()
	{
		var stringToReturn;
		stringToReturn = "  " + this.stateStringComment + "\n  " + this.stateString + "\n\n"; 
		return stringToReturn;
	
	}
	this.getMachineState = function()
	{
	        var stringToReturn;
		stringToReturn = "  " + this.machineStateComment + "\n  " + this.machineState + "\n\n";
		return stringToReturn;
	}
	this.getInitialState = function()
	{
	        var stringToReturn;
	        stringToReturn = "  " + this.initialStateComment + "\n  " + this.initialState + "\n\n";
		return stringToReturn;
	}

	

 }

 function rebuild()
 {
	return writer.init               + 
               writer.getStateString()   + 
	       writer.getMachineState()  +
	       writer.getInitialState()  + 
	       writer.getAllTransition() +
               writer.end;
	
 }




</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-stateToPvsSpecificationWriter.html">stateToPvsSpecificationWriter</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-dev</a> on Mon Oct 28 2013 15:54:37 GMT-0000 (GMT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
